## Section 4 IP 주소

### 2.4.1 ARP

컴퓨터와 컴퓨터 간의 통신은 IP주소 → ARP → MAC 주소를 찾아 MAC 주소를 기반으로 통신

※ MAC 주소 : 컴퓨터나 노트북 등 각 장치에는 네트워크에 연결하기 위한 장치(LAN 카드)가 있는데, 이를 구별하기 위한 식별번호, 6바이트로 구성

- **ARP (Address Resolution Protocol)**
    - IP 주소로부터 MAC 주소를 구하는 IP와 MAC 주소의 다리 역할을 하는 프로토콜
    - ARP를 통해 가상 주소인 IP 주소를 실제 주소인 MAC 주소로 변환
        
        ↔ RARP 를 통해 실제 주소인 MAC 주소를 가상 주소인 IP 주소로 변환하기도 함
        
    
    - **ARP의 주소 찾는 과정**
        1. 장치 A가 ARP Request 브로드캐스트를 보냄 (IP 주소)
            
            ※ **브로드캐스트** : 송신 호스트가 전송한 데이터가 네트워크에 연결된 모든 호스트에 전송되는 방식
            
        2. IP 주소에 해당하는 MAC 주소 찾음
        3. 해당 주소에 맞는 장치 B가 ARP Replay 유니캐스트를 통해 MAC 주소 반환
            
            ※ **유니캐스트** : 고유 주소로 식별된 하나의 네트워크 목적지에 1:1로 데이터 전송하는 방식
            
        4. IP 주소에 맞는 MAC 주소 찾게 됨

### 2.4.2 홉바이홉 통신

: IP 주소를 통해 통신하는 과정

※ **홉 (hop)** : 건너뛰는 모습

→ 통신망에서 각 패킷이 여러 개의 라우터를 건너가는 모습

수많은 서브네트워크 안에 있는 라우터의 라우팅 테이블 IP를 기반으로 패킷 전달해가며 라우팅 수행하여 최종 목적지까지 패킷 전달

통신 장치에 있는 ‘라우팅 테이블’의 IP를 통해 시작 주소부터 시작하여 다음 IP로 계속 이동하는 ‘라우팅’ 과정을 거쳐 패킷이 최종 목적지까지 도달하는 통신

※ **라우팅** : IP 주소를 찾아가는 과정

- **라우팅 테이블 (Routing Table)**
    - 송신지에서 수신지까지 도달하기 위해 사용
    - 라우터에 들어가 있는 목적지 정보들과 그 목적지로 가기 위한 방법이 들어 있는 리스트
    - 게이트웨이와 모든 목적지에 대해 해당 목적지에 도달하기 위해 거쳐야 할 다음 라우터의 정보를 가지고 있음

- **게이트웨이 (Gateway)**
    - 서로 다른 통신망, 프로토콜을 사용하는 네트워크 간의 통신을 가능하게 하는 관문 역할을 하는 컴퓨터나 소프트웨어
    - 서로 다른 네트워크상의 통신 포로토콜 변환
    - 사용자가 인터넷에 접속하기 위해서는 게이트웨이들을 거쳐야 함
    
    - 게이트웨이 확인 방법
        - 라우팅 테이블 통해 확인
            
            → netstat -r 명령어 실행하여 확인
            

### 2.4.3 IP 주소 체계

- **IPv4**
    - 32비트를 8비트 단위로 점을 찍어 표기
    - 123.45.67.89 방식
    - 현재 가장 많이 쓰이는 주소 체계
- **IPv6**
    - 64비트를 16비트 단위로 점을 찍어 표기
    - 2001:db8::ff00:8329 방식
    - IPv6를 사용하는 추세

- **클래스 기반 할당 방식**
    
    IP 주소 체계는 처음에 A, B, C, D, E 다섯 개의 클래스로 구분하는 클래스 기반 할당 방식 사용했음
    
    - **일대일 통신**
        - **클래스 A** : 네트워크 주소 1 BYTE, 호스트 주소 3 BYTE (0.0.0.0 ~ 127.255.255.255)
        - **클래스 B** : 네트워크 주소 2 BYTE, 호스트 주소 2 BYTE (128.0.0.0 ~ 191.255.255.255)
        - **클래스 C** : 네트워크 주소 3 BYTE, 호스트 주소 1 BYTE (192.0.0.0 ~ 223.255.255.255)
    - **멀티캐스트 통신**
        - **클래스 D** : 브로드캐스트용 주소 4 BYTE
    - **예비용**
        - **클래스 E** : 예비용 주소 4 BYTE
    
    - **구분 비트** : 맨 왼쪽에 있는 비트
    - **네트워크의 첫 번째 주소** : 네트워크 구별 주소로 사용
    - **가장 마지막 주소** : 브로드캐스트용 주소 → 네트워크에 속해 있는 모든 컴퓨터에 데이터를 보낼 때 사용
        
        ex) 클래스 A로 12.0.0.0 네트워크 부여받음 → 12.0.0.1 ~ 12.255.255.254 를 컴퓨터에 부여할 수 있는 호스트 주소로 사용 가능
        
        첫 번째 주소인 12.0.0.0 은 네트워크 구별 주소, 12.255.255.255 는 브로드캐스트용으로 남겨두어야 함
        
    
    → 사용하는 주소보다 버리는 주소가 많다는 단점
    
    → 이를 해소하기 위해 DHCP, IPv6, NAT 등장
    
- **DHCP (Dynamic Host Configuration Protocol)**
    - IP 주소 및 기타 통신 매개변수를 동적으로 할당하기 위한 네트워크 관리 프로토콜
        
        → 네트워크 장치의 IP 주소를 수동으로 설정할 필요 X
        
        → 인터넷에 접속할 때마다 자동으로 IP 주소 할당 가능
        
    - 많은 라우터와 게이트웨이 장비에 DHCP 기능이 있음
        
        → 대부분의 가정용 네트워크에서 IP 주소 할당 가능
        

- **NAT (Network Address Translation)**
    - 패킷이 라우팅 장치를 통해 전송되는 동안 패킷의 IP 주소 정보를 수정하여 IP 주소를 다른 주소로 매칭하는 방법
    - IPv4 주소 체계만으로는 많은 주소들을 모두 감당하지 못함
        
        → NAT로 공인 IP 와 사설 IP로 나눠 많은 주소 처리
        
    - ICS, RRAS, Netfilter 등의 소프트웨어로 NAT 가능
    
    ex) 사설 IP → NAT 장치 → 공인 IP로 외부 인터넷에 요청
    
    - NAT 장치를 통해 사설 IP를 공인 IP로 변환 OR 공인 IP를 사설 IP로 변환 가능
    
    - **공유기와 NAT**
        
        NAT 사용 이유 : 여러 대의 호스트가 하나의 공인 IP 주소를 사용하여 인터넷에 접속하기 위함
        
        → 인터넷 회선 하나 개통하고 인터넷 공유기 달아서 여러 PC 연결하여 사용 가능
        
        → 인터넷 공유기에 NAT 기능이 탑재되어 있기 때문
        
    - **NAT 를 이용한 보안**
        
        내부 네트워크에서 사용하는 IP 주소와 외부에 드러나는 IP 주소를 다르게 유지할 수 있음
        
        → 어느 정도의 보안이 가능
        
    - **NAT 의 단점**
        
        여러 명이 동시에 인터넷 접속
        
        → 실제로 접속하는 호스트 숫자에 따라서 접속 속도가 느려질 수 있음
        

### 2.4.4 IP 주소를 이용한 위치 정보

IP 주소는 인터넷에서 사용하는 네트워크 주소이기 때문에 이를 통해 동 또는 구까지 위치 추적 가능

---

## Section 5 HTTP

HTTP는 애플리케이션 계층으로서 웹 서비스 통신에 사용됨

### 2.5.1 HTTP/1.0

한 연경 당 하나의 요청 처리

→ 서버로부터 파일을 가져올때마다 TCP의 3-웨이 핸드셰이크를 계속해서 열어야 함

→ RTT 증가를 불러옴

※ **RTT** : 패킷이 목적지에 도달하고 나서 다시 출발지로 돌아오기까지 걸리는 시간, 패킷 왕복 시간

- **RTT의 증가를 해결하기 위한 방법**
    
    매번 연결할 때마다 RTT 증가
    
    → 서버에 부담이 많이 가고 사용자 응답 시간이 길어짐
    
    → 이미지 스플리팅, 코드 압축, 이미지 Base64 인코딩 사용
    
    - **이미지 스플리팅**
        
        많은 이미지를 다운로드 받으면 과부하 걸림
        
        → 많은 이미지가 합쳐 있는 하나의 이미지 다운로드
        
        → 이를 기반으로 background-image의 position 이용하여 이미지 표기
        
    - **코드 압축**
        
        코드를 압축해서 개행 문자, 빈칸을 없애 코드의 크기 최소화하는 방법
        
    - **이미지 Base64 인코딩**
        
        이미지 파일을 64진법으로 이루어진 문자열로 인코딩하는 방법
        
        - 장점 : 서버와의 연결을 열고 이미지에 대해 서버에 HTTP 요청을 할 필요가 없음
        - 단점 : Base64 문자열로 변환할 경우 37% 정도 크기가 더 커짐
        

### 2.5.2 HTTP/1.1

매번 TCP 연결 하지 않고 한 번 TCP 초기화 한 이후 keep-alive 옵션으로 여러 개의 파일 송수신

- **HTTP/1.0**
    1. TCP handshake
    2. GET
    3. RESPONSE
    4. TCP Teardown
    
    → 1~4 반복
    
- **HTTP/1.1**
    1. TCP handshake
    2. GET → RESPONSE → GET → RESPONSE → GET → RESPONSE
    3. TCP Teardown

한 번 TCP 3-웨이 핸드셰이크 발생 → 그 다음부터 발생 X

**단점** : 문서 안에 포함된 다수의 리소스 (이미지, 동영상, css 파일 등)를 처리하려면 요청할 리소스 개수에 비례해서 대기 시간이 길어짐

- **HOL Blocking (Head Of Line Blocking)**
    
    : 네트워크에서 같은 큐에 있는 패킷이 그 첫 번째 패킷에 의해 지연이 발생하는 성능 저하 현상
    
    패킷이 순차적으로 다운로드되는데 첫 번째 패킷 다운로드에 지연이 발생하면서 그 뒤에 있는 것들이 대기하며 다운로드가 지연되는 상태
    
- **무거운 헤더 구조**
    
    쿠키 등 많은 메타데이터가 들어 있고 압축이 되지 않아 무거워짐
    

### 2.5.3 HTTP/2

SPDY 프로토콜에서 파생된 HTTP/1.X보다 지연 시간을 줄이고 응답 시간 더 빠르게 가능

멀티플렉싱, 헤더 압축, 서버 푸시, 요청의 우선순위 처리 지원 프로토콜

- **멀티플렉싱**
    
    : 여러 개의 스트림을 사용하여 송수신
    
    → 특정 스트림의 패킷이 손실되었다고 하더라도 해당 스트림에만 영향을 미침
    
    ※ **스트림** : 시간이 지남에 따라 사용할 수 있게 되는 일련의 데이터 요소를 가리키는 데이터 흐름
    
    - **병렬적 스트림을 통한 데이터 서빙**
        - 스트림 내의 데이터도 쪼개져 있음
        - 애플리케이션에서 받아온 메시지를 독립된 프레임으로 조각내어 서로 송수신한 이후 다시 조립하여 데이터 주고받음
    
    → 단일 연결 사용하여 병렬로 요청, 응답 가능
    
    → HOL Blocking 문제 해결
    
- **헤더 압축**
    - HTTP/1.X의 큰 헤더 문제 → HTTP/2에서 헤더 압축을 써서 해결
        - 허프만 코딩 압축 알고리즘
            - HPACK 압축 형식
            - 문자열을 문자 단위로 쪼개 빈도수를 셈
            - 빈도가 높은 정보는 적은 비트 수를 사용하여 표현
            - 빈도가 낮은 정보는 비트 수를 많이 사용하여 표현
            
            → 전체 데이터의 표현에 필요한 비트양을 줄임
            

- **서버 푸시**
    - HTTP/1.1은 클라이언트가 서버에 요청해야 파일 다운로드 가능 → HTTP/2 는 클라이언트 요청 없이 서버가 리소스 푸시 가능
        
        EX) html에는 css나 js 파일 포함
        
        → html을 읽으면서 그 안에 들어 있던 css 파일을 서버에서 푸시 → 클라이언트에게 바로 줄 수 있음
        

### 2.5.4 HTTPS

HTTP/2는 HTTPS 위에서 동작

**HTTPS** : 애플리케이션 계층과 전송 계층 사이에 신뢰 계층인 SSL/TLS 계층을 넣은 신뢰할 수 있는 HTTP 요청

→ 통신 암호화

- **SSL/TLS**
    - SSL (Secure Socket Layer) → TLS (Transport Layer Sercuity Protocol) 로 명청 변경
    - 전송 계층에서 보안을 제공하는 프로토콜
        - 클라이언트와 서버가 통신할 때 SSL/TLS를 통해 제3자가 메시지 도청/변조 못하게 막음
        - 공격자가 서버인 척하며 사용자 정보 가로채는 ‘인터셉트’ 방지 가능
    - 보안 세션을 기반으로 데이터 암호화
    - 보안 세션이 만들어질 때 인증 매커니즘, 키 교환 암호화 알고리즘, 해싱 알고리즘 사용
        - **보안 세션**
            - 보안이 시작되고 끝나는 동안 유지되는 세션
                
                ※ 세션 : 운영체제가 사용자로부터 자신의 자산 이용을 허락하는 일정 기간
                
            - 클라이언트와 서버가 키를 공유
                
                → 이를 기반으로 인증, 인증 확인
                
                → 단 한번의 1-RTT 생긴 후 데이터 송수신
                
            - 클라이언트에서 사이퍼 슈트 서버에 전달
                
                → 서버는 전달받은 사이퍼 슈트의 암호화 알고리즘 리스트 제공 가능한지 확인
                
                → 제공 가능하다면 서버에서 클라이언트로 인증서 보내는 인증 매커니즘 시작
                
                → 해싱 알고리즘 등으로 암호화된 데이터의 송수신 시작
                
                ※ 사이퍼 슈트 : 프로토콜, AEAD 사이퍼 모드, 해싱 알고리즘이 나열된 규약
                
                ※ AEAD 사이퍼 모드 : Authenticated Encryption with Associated Data, 데이터 암호화 알고리즘
                
        
        - **인증 매커니즘**
            - **CA (Certificate Authorities)에서 발급한 인증서**를 기반으로 이루어짐
                - 안전한 연결을 시작하는 데 필요한 ‘공개키’를 클라이언트에 제공
                - 사용자가 접속한 서버가 ‘신뢰할 수 있는 서버’임을 보장
                - 서비스 정보, 공개키, 지문, 디지털 서명 등으로 이루어짐
            - 신뢰성이 엄격하게 공인된 기업만 참여 가능
            - CA 발급 과정
                1. 자신의 사이트 정보와 공개키를 CA에 제출
                2. 공개키를 해시한 값인 지문을 사용하는 CA의 비밀키를 기반으로 CA  인증서 발급
        
        - **암호화 알고리즘**
            - 디피-헬만 방식 → 대수곡선 기반 ECDGE, 모듈식 기반 DHE 사용
            - **디피-헬만 키 교환 암호화 알고리즘**
                - 암호키를 교환하는 하나의 방법
                1. 공개 값 공유
                2. 각자의 비밀 값과 혼합
                3. 혼합 값 공유
                4. 각자의 비밀 값과 재혼합
                5. 공통의 암호키인 PSK (Pre-Shared Key) 생성
            
        - **해싱 알고리즘**
            - 데이터를 추정하기 힘든 더 작고, 섞여 있는 조각으로 만드는 알고리즘
            - 전처리된 메시지를 기반으로 해시 반환
            - 해시 함수의 결괏값은 256비트
            
- **SEO에도 도움이 되는 HTTPS**
    - **SEO (Search Engine Optimization)** : 검색엔진 최적화
        - 검색엔진으로 웹 사이트 검색 시 그 결과를 페이지 상단에 노출시켜 많은 사람이 볼 수 있도록 최적화하는 방법
        - **캐노니컬 설정**
            - <link rel=”canonical” href=”~~”/> 와 같이 사이트 link에 캐노니컬 설정
        - **메타 설정**
            - html 파일의 가장 윗부분인 메타 설정
        - **페이지 속도 개선**
        - **사이트맵 관리**

- **HTTPS 구축 방법**
    1. 직접 CA에서 구매한 인증키를 기반으로 HTTPS 서비스 구축
    2. 서버 앞단의 HTTPS를 제공하는 로드밸런서 두기
    3. 서버 앞단에 HTTPS를 제공하는 CDN을 두기

### 2.5.5 HTTPS/3

HTTP/2 : TCP 위에서 동작

HPPT/3 : QUIC 계층 위에서 동작, UDP 기반으로 동작, 멀티플렉싱 가능, 초기 연결 설정 시 지연 시간 감소

- 초기 연결 설정 시 지연 시간 감소
    - QUIC은 TCP 사용하지 않기 때문에 3-웨이 핸드셰이크 과정 필요 없음
    - 첫 연결 설정에 1-RTT만 소요
        - 클라이언트가 서버에 신호 한 번 주고, 서버도 응답하면 본 통신 시작 가능
    - 순방향 오류 수정 메커니즘 적용
        - 전송한 패킷 손실 시 수신 측에서 에러 검출, 수정
        - 열악한 네트워크 환경에서도 낮은 패킷 손실률 자랑
